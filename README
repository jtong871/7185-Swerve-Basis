This is the official code currently under construction by FRC team 7185. Code isn't complete and tweaked yet, and will be need to be modified in the future!
If you're attempting to use this code for a future chassis, know that many parameters need to be modified, and that swerve is a programming nightmare, requiring more advanced hardware and programming from traditional tank drive, such as Encoders and PID Controllers.




Here's a simple breakdown of how Encoders and PID Controllers are used.


Encoders are needed to read the amount a motor has spun relative to its start point, which is usually set when the robot boots up. This is crucial for swerve, where joystick inputs have to influence how many radians the motor has to spin, not directly control motor output. Encoders get their values through encoder ticks/pulses, which vary from encoder to encoder. Typically, encoders have 4096 pulses per motor rotation, but encoder values have to additionally be converted by gear ratio, wheel diameter, and etc.

Motor outputs used to set wheel angles to specific positions are calculated by PID Controllers. In a nutshell, PID controllers use 3 different calculations in order to get motors to rotate a specific number of times very fast, and very accurately. PID stands for proportional, integral, and derivative. The proportional calculation measures the rotation needed for the motors to get to a desired location, called error, and sets motor output in proportion to how large the error is. The proportional calculation is usually accurate enough for something like swerve, but integral and derivative terms should be learned for optimization, which requires a small amount of calculus knowledge.

The integral term takes the integral of the error with respect to time, and sets the motor output accordingly, in order to counter error which may be too small for the proportional term to close because of friction or air resistance. 

The derivative term takes the current velocity of the motor, and sets the motor output accordingly, in order to eliminate possibility of overshoot.

Each of these terms require a specific constant they need to be multiplied by, which happens to be different for each robot. For example, one robot may have terms kP, kI, and kD set to 0.05, 0.4, 0.08, respectively, but another robot may have terms 0.03, 0.6, and 0.02, respectively. These terms cannot be calculated (although they can be estimated), and as such, need to be tuned, which takes a lot of time.


Code Outline: 

The code starts in SwerveModule.java, where all of the motor and encoder declarations are created. There, a module is defined by its motors, encoders, a PID Controller that allows for each module to turn to certain positions in accordance to user input modified by the SwerveDriveKinematicsClass, and other parameters. As of now, the only declarations are made for a single module, as 4 instances of SwerveModule object are created in the SwerveSubsystem class. In essence, SwerveModule.java defines the hardware of a module as well as all of the parameters needed, while SwerveSubsystem.java uses those parameters to create each of the 4 swerve modules on the robot. Various methods are used to access values that are given by various hardware within the module, which is needed for swerve. WPI Libraries help automatically calculate the best wheel angles and speeds in order to drive swerve, but WPI libraries need information given through these methods in order to make these calculations. 

In RobotContainer.java, a SwerveSubsystem instance is given, which is used for button bindings. There, a new driver joystick is made, as well as an optional gunner joystick in the case that 2 drivers is preferrable. Joystick inputs from the driver are constantly updated, while buttons are bound to execute certain commands, such as the Start button being used to tell the robot to reset gyroscope heading. The gyroscope is used for field oriented drive, so being able to zero the heading allows the robot to reset what the robot is driving relative to. Field oriented drive allows the robot to move in a one-to-one reference to the joystick, regardless of where the robot is pointing. For example, if you are standing next to the robot's left side, pushing the joystick forward makes the robot move away from you directly, instead of moving towards your left side when in a robot relative reference frame. This makes driving very easy, which is why the gyroscope is preferrable.

SwerveCmd.java is set as the default command for this robot, which is what drives the robot during teleOp. SwerveCmd.java takes the joystick inputs that were read from RobotContainer.java as well as the robot's heading if the robot is in field oriented mode, and translates it into an x speed, a y speed, and a turning speed for the robot, known as the ChassisSpeeds object inputStates. There, inputStates is converted into an array of SwerveModuleStates called moduleStates, which defines the speeds and angles desired for each individual swerve module. Finally, it uses the setModuleStates (created with the setStates method in SwerveModule.java) created in SwerveSubsystem.java to set each wheel to the specified angle and speed. 

Autonomous would be defined in RobotContainer where an odometer and several coordinate points are used to project and follow a trajectory, but autonomous isn't yet in the works.



//TODO: Figure out turn gear ratio, tune PID Controller, find abs Encoder Offset, debug any Encoder issues, set parameters for each module